(window.webpackJsonp=window.webpackJsonp||[]).push([["chunk-27ae6973"],{"0b7e":function(n,e,r){"use strict";r.d(e,"a",function(){return t}),r.d(e,"b",function(){return a});var t=function(){var n=this,e=n.$createElement,e=n._self._c||e;return e("div",{staticClass:"smartContract"},[e("PurpleTitle",[e("div",[e("img",{attrs:{src:r("5fb6")}}),e("span",[n._v(n._s(n.$t("SmartContractCode")))])])]),n._m(0)],1)},a=[function(){var n=this,e=n.$createElement,e=n._self._c||e;return e("div",{staticClass:"smartContractContent"},[e("code",[e("pre",[n._v('pragma solidity >=0.5.0 <0.6.0;\n\n/**\n * @dev Wrappers over Solidity\'s arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it\'s recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\'s `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint a, uint b) internal pure returns (uint) {\n        uint c = a + b;\n        require(c >= a, "SafeMath: addition overflow");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\'s `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint a, uint b) internal pure returns (uint) {\n        return sub(a, b, "SafeMath: subtraction overflow");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\'s `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\n        require(b <= a, errorMessage);\n        uint c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\'s `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint a, uint b) internal pure returns (uint) {\n        if (a == 0) {\n            return 0;\n        }\n\n        uint c = a * b;\n        require(c / a == b, "SafeMath: multiplication overflow");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\'s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint a, uint b) internal pure returns (uint) {\n        return div(a, b, "SafeMath: division by zero");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\'s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\n        require(b > 0, errorMessage);\n        uint c = a / b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity\'s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint a, uint b) internal pure returns (uint) {\n        return mod(a, b, "SafeMath: modulo by zero");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity\'s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n\npragma solidity >=0.5.1 <0.7.0;\n\ninterface iERC777_1 {\n\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address account) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function transfer(address recipient, uint amount) external returns (bool);\n    function approve(address spender, uint amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint amount) external returns (bool);\n    function increaseAllowance(address spender, uint addedValue) external returns (bool);\n    function decreaseAllowance(address spender, uint subtractedValue) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint value);\n    event Approval(address indexed owner, address indexed spender, uint value);\n\n    function granularity() external view returns (uint);\n    function defaultOperators() external view returns (address[] memory);\n\n    function addDefaultOperators(address owner) external returns (bool);\n    function removeDefaultOperators(address owner) external returns (bool);\n\n    function isOperatorFor(address operator, address holder) external view returns (bool);\n    function authorizeOperator(address operator) external;\n    function revokeOperator(address operator) external;\n\n    function send(address to, uint amount, bytes calldata data) external;\n    function operatorSend(address from, address to, uint amount, bytes calldata data, bytes calldata operatorData) external;\n\n    function burn(uint amount, bytes calldata data) external;\n    function operatorBurn(address from, uint amount, bytes calldata data, bytes calldata operatorData) external;\n\n    event Sent(address indexed operator, address indexed from, address indexed to, uint amount, bytes data, bytes operatorData);\n    event Minted(address indexed operator, address indexed to, uint amount, bytes data, bytes operatorData);\n    event Burned(address indexed operator, address indexed from, uint amount, bytes data, bytes operatorData);\n    event AuthorizedOperator(address indexed operator, address indexed holder);\n    event RevokedOperator(address indexed operator, address indexed holder);\n}\n\n\npragma solidity >=0.5.1 <0.6.0;\n\n\n\n\ncontract ERC777_1TokenStorage is KStorage {\n\n    using SafeMath for uint;\n\n    address[] internal _defaultOperators;\n\n    mapping (address => uint) internal _balances;\n    mapping (address => mapping(address => uint)) internal _allowances;\n    mapping (address => mapping(address => bool)) internal _authorized;\n\n    string public name;\n    string public symbol;\n    uint8 public decimals = 18;\n    uint public totalSupply;\n    uint public granularity = 1;\n\n    event Transfer(address indexed from, address indexed to, uint value);\n    event Approval(address indexed owner, address indexed spender, uint value);\n\n    /**\n     * @dev Constructor.\n     */\n    /* constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals,\n        uint _totalSupply\n    ) public {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n        totalSupply = _totalSupply;\n\n        _balances[address(this)] = _totalSupply;\n        _defaultOperators.push(msg.sender);\n    } */\n\n    function balanceOf(address account) external view returns (uint) {\n        return _balances[account];\n    }\n\n    function allowance(address owner, address spender) external view returns (uint) {\n        return _allowances[owner][spender];\n    }\n\n    function transfer(address, uint) external returns (bool) {\n        address impl_address = KImplementAddress;\n        assembly {\n            calldatacopy(0x0, 0x0, calldatasize())\n            let success := delegatecall(gas(), impl_address, 0x0, calldatasize(), 0, 0)\n            let retSz := returndatasize()\n            returndatacopy(0, 0, retSz)\n            switch success\n            case 0 {\n                revert(0, retSz)\n            }\n            default {\n                return(0, retSz)\n            }\n        }\n    }\n\n    function approve(address, uint) external returns (bool) {\n        address impl_address = KImplementAddress;\n        assembly {\n            calldatacopy(0x0, 0x0, calldatasize())\n            let success := delegatecall(gas(), impl_address, 0x0, calldatasize(), 0, 0)\n            let retSz := returndatasize()\n            returndatacopy(0, 0, retSz)\n            switch success\n            case 0 {\n                revert(0, retSz)\n            }\n            default {\n                return(0, retSz)\n            }\n        }\n    }\n\n    function transferFrom(address, address, uint) external returns (bool) {\n        address impl_address = KImplementAddress;\n        assembly {\n            calldatacopy(0x0, 0x0, calldatasize())\n            let success := delegatecall(gas(), impl_address, 0x0, calldatasize(), 0, 0)\n            let retSz := returndatasize()\n            returndatacopy(0, 0, retSz)\n            switch success\n            case 0 {\n                revert(0, retSz)\n            }\n            default {\n                return(0, retSz)\n            }\n        }\n    }\n\n}\n\ncontract ERC777_1Token is iERC777_1, ERC777_1TokenStorage {\n\n    /* constructor() public ERC777_1TokenStorage("", "", 0, 0) {} */\n\n    function transfer(address recipient, uint amount) external KWhenNotPaused returns (bool) {\n        _send(msg.sender, recipient, amount, "", msg.sender, "");\n        return true;\n    }\n\n    function approve(address spender, uint value) external KWhenNotPaused returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    function transferFrom(address sender, address recipient, uint amount) external KWhenNotPaused returns (bool) {\n        require(amount <= _allowances[sender][msg.sender]);\n        _allowances[sender][msg.sender] = _allowances[sender][msg.sender].sub(amount);\n        _send(sender, recipient, amount, "", msg.sender, "");\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint addedValue) external KWhenNotPaused returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint subtractedValue) external KWhenNotPaused returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));\n        return true;\n    }\n\n    function addDefaultOperators(address owner) external KOwnerOnly returns (bool) {\n        _defaultOperators.push(owner);\n    }\n\n    function removeDefaultOperators(address owner) external KOwnerOnly returns (bool) {\n        for (uint i = 0; i < _defaultOperators.length; i++) {\n            if ( _defaultOperators[i] == owner ) {\n                for (uint j = i; j < _defaultOperators.length - 1; j++) {\n                    _defaultOperators[j] = _defaultOperators[j+1];\n                }\n                delete _defaultOperators[_defaultOperators.length - 1];\n                _defaultOperators.length --;\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function defaultOperators() external view returns (address[] memory) {\n        return _defaultOperators;\n    }\n\n    function authorizeOperator(address _operator) external {\n        require(_operator != msg.sender);\n        _authorized[_operator][msg.sender] = true;\n        emit AuthorizedOperator(_operator, msg.sender);\n    }\n\n    function revokeOperator(address _operator) external {\n        require(_operator != msg.sender);\n        _authorized[_operator][msg.sender] = false;\n        emit RevokedOperator(_operator, msg.sender);\n    }\n\n    function send(address _to, uint _amount, bytes calldata _userData) external {\n        _send(msg.sender, _to, _amount, _userData, msg.sender, "");\n    }\n\n    function isOperatorFor(address _operator, address _tokenHolder) public view returns (bool) {\n        for (uint i = 0; i < _defaultOperators.length; i++) {\n            if ( _defaultOperators[i] == _operator )  {\n                return true;\n            }\n        }\n        return _operator == _tokenHolder || _authorized[_operator][_tokenHolder];\n    }\n\n    function operatorSend(address _from, address _to, uint _amount, bytes calldata _userData, bytes calldata _operatorData) external {\n        require( isOperatorFor(msg.sender, _from), "NotAuthorized" );\n        _send(_from, _to, _amount, _userData, msg.sender, _operatorData);\n    }\n\n    function mint(address _tokenHolder, uint _amount, bytes calldata _operatorData) external KOwnerOnly {\n        totalSupply = totalSupply.add(_amount);\n        _balances[_tokenHolder] = _balances[_tokenHolder].add(_amount);\n        emit Minted(msg.sender, _tokenHolder, _amount, "", _operatorData);\n    }\n\n    function burn(uint _amount, bytes calldata _data) external {\n        _send(msg.sender, address(0x0), _amount, _data, msg.sender, "");\n    }\n\n    function operatorBurn(\n        address _from,\n        uint _amount,\n        bytes calldata _data,\n        bytes calldata _operatorData\n    ) external {\n        require(isOperatorFor(msg.sender, _from), "NotAuthorized");\n        _send(_from, address(0x0), _amount, _data, msg.sender, _operatorData);\n    }\n\n    function _send(\n        address _from,\n        address _to,\n        uint _amount,\n        bytes memory _userData,\n        address _operator,\n        bytes memory _operatorData\n    ) internal {\n\n\n        _balances[_from] = _balances[_from].sub(_amount);\n        _balances[_to] = _balances[_to].add(_amount);\n\n        if ( _to == address(0) ) {\n            totalSupply -= _amount;\n            emit Burned(_operator, _from, _amount, _userData, _operatorData);\n        } else {\n            emit Sent(_operator, _from, _to, _amount, _userData, _operatorData);\n        }\n\n        emit Transfer(_from, _to, _amount);\n    }\n\n    function _approve(address owner, address spender, uint value) internal {\n        require(owner != address(0), "ERC20: approve from the zero address");\n        require(spender != address(0), "ERC20: approve to the zero address");\n\n        _allowances[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n}\n\n\ncontract TronTrc20TestToken is ERC777_1TokenStorage {\n    constructor() public {\n        name = "TRC20TokenTemplate";\n        symbol = "TRCT";\n        decimals = 6;\n        totalSupply = 100000000e6;\n\n        _balances[address(this)] = totalSupply;\n        _defaultOperators.push(msg.sender);\n    }\n}\n\n\npragma solidity >=0.5.0 <0.6.0;\n\n\ncontract RelationsStorage is KStorage {\n\n    enum AddRelationError {\n        NoError,\n        CannotBindYourSelf,\n        AlreadyBinded,\n        ParentUnbinded,\n        ShortCodeExisted\n    }\n\n    address public rootAddress = address(0xdead);\n\n    uint public totalAddresses;\n\n    mapping (address => address) internal _recommerMapping;\n\n    mapping (address => address[]) internal _recommerList;\n\n    mapping (address => bytes16) internal _nickenameMapping;\n\n    mapping (address => uint) internal _depthMapping;\n\n    constructor() public {\n        _recommerMapping[rootAddress] = address(0xdeaddead);\n    }\n}\n\ncontract Relations is RelationsStorage {\n\n    function getIntroducer(address owner) external view returns (address) {\n        return _recommerMapping[owner];\n    }\n\n    function recommendList(address owner) external view returns (address[] memory) {\n        return (_recommerList[owner]);\n    }\n\n    function addressToNickName(address addr) external view returns (bytes16) {\n        return _nickenameMapping[addr];\n    }\n\n    function depth(address addr) external view returns (uint) {\n        return _depthMapping[addr];\n    }\n\n    function updateNickName(bytes16 name) external {\n        _nickenameMapping[msg.sender] = name;\n    }\n\n    function addRelationEx(address recommer, bytes16 nickname) external returns (AddRelationError) {\n\n        if ( recommer == msg.sender )  {\n            return AddRelationError.CannotBindYourSelf;\n        }\n\n        if ( _recommerMapping[msg.sender] != address(0x0) ) {\n            return AddRelationError.AlreadyBinded;\n        }\n\n        if ( recommer != rootAddress && _recommerMapping[recommer] == address(0x0) ) {\n            return AddRelationError.ParentUnbinded;\n        }\n\n        totalAddresses++;\n        _nickenameMapping[msg.sender] = nickname;\n\n        _recommerMapping[msg.sender] = recommer;\n        _recommerList[recommer].push(msg.sender);\n\n        _depthMapping[msg.sender] = _depthMapping[recommer] + 1;\n\n        return AddRelationError.NoError;\n    }\n}\n\n\npragma solidity >=0.5.1 <0.6.0;\n\ncontract ICATokenStorage is ERC777_1TokenStorage {\n\n    address public constant BurnedAddress = address(0x0);\n\n    address public constant BonusAddress_L1 = address(0x1);\n    address public constant BonusAddress_L2 = address(0x2);\n    address public constant BonusAddress_L3 = address(0x3);\n    address public constant BonusAddress_L4 = address(0x4);\n    address public constant BonusAddress_L5 = address(0x5);\n\n    address public constant TopRewardAddress = address(0xA);\n\n    address public constant GenesisesAddress = address(0xB);\n\n    address public constant HolderAddress = address(0xC);\n\n    address public constant UpgradeLevelAddress = address(0xD);\n\n    mapping(uint => uint) internal _tradingVolumeMapping;\n\n    Relations internal iRelations;\n\n    address public swapPairAddress;\n\n    mapping(address => bool) internal _whiteListMapping;\n    bool public whiteListModeEnable;\n\n\n\n    event Log_ToperHistory(uint indexed time, address[10] owner, uint[10] awards );\n    struct AchievementHistory {address owner; uint total; uint actualSent;}\n    mapping(address => mapping(uint => uint) ) public dayAchievementOf;\n    mapping(uint => AchievementHistory[10]) public topAddressesOf;\n    uint public latestTimeOfTopAward;\n\n\n    struct HolderInfo {uint total; uint unlockTime; uint level; uint vaildAddressCount; }\n    event Log_TransferHold(address indexed owner, uint time, int value, uint total);\n    event Log_HoldAwardDistribute(address indexed owner, uint indexed lv, uint time, uint award);\n    uint[6] public latestDistributeTime;\n    mapping(address => HolderInfo) public holderInfoOf;\n    mapping(uint => address[]) internal _levelListMapping;\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals,\n        uint _totalSupply,\n        Relations _rlsInc\n    ) public  {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n        totalSupply = _totalSupply;\n        iRelations = _rlsInc;\n\n        _allowances[GenesisesAddress][msg.sender] = 2 ** 256 - 1;\n        /* _balances[UpgradeLevelAddress] = 1000000e6; */\n        _balances[msg.sender] = _totalSupply - _balances[UpgradeLevelAddress];\n\n        _defaultOperators.push(msg.sender); */\n    }\n\n}\n\n\npragma solidity >=0.5.1 <0.6.0;\n\n\ncontract ICAToken_Internal_Top is ERC777_1TokenStorage, ICATokenStorage, ERC777_1Token {\n\n    function distributeTopAwards() external KOwnerOnly returns (address[10] memory addresses, uint[10] memory awards) {\n\n        uint dayz = timestempZero();\n\n        /* if ( dayz != latestTimeOfTopAward ) { */\n        latestTimeOfTopAward = timestemp();\n\n        uint totalAwards = _balances[TopRewardAddress];\n        AchievementHistory[10] storage yesterdayTops = topAddressesOf[dayz - 1 days];\n\n        uint40[3] memory props = [\n            0.3e12,\n            0.2e12,\n            0.1e12\n        ];\n\n        for ( uint i = 0; i < props.length && i < yesterdayTops.length; i++ ) {\n            address owner = yesterdayTops[i].owner;\n            if ( owner != address(0) ) {\n                addresses[i] = owner;\n                awards[i] = totalAwards * props[i] / 1e12;\n                yesterdayTops[i].actualSent = awards[i];\n                _balances[TopRewardAddress] = _balances[TopRewardAddress].sub(awards[i]);\n                _balances[owner] = _balances[owner].add(awards[i]);\n                emit Transfer(TopRewardAddress, owner, awards[i]);\n            }\n        }\n\n        totalAwards = _balances[TopRewardAddress] / 7;\n        for ( uint i = 3; i < 10; i++ ) {\n            address owner = yesterdayTops[i].owner;\n            if ( owner != address(0) ) {\n                addresses[i] = owner;\n                awards[i] = totalAwards;\n\n                _balances[TopRewardAddress] = _balances[TopRewardAddress].sub(awards[i]);\n                _balances[owner] = _balances[owner].add(awards[i]);\n                emit Transfer(TopRewardAddress, owner, awards[i]);\n            }\n        }\n\n        emit Log_ToperHistory(dayz, addresses, awards);\n        /* } */\n\n    }\n\n    function currentTops() external view returns (address[10] memory addresses, uint[10] memory totals) {\n        uint dayz = timestempZero();\n        for (uint i = 0; i < 10; i++) {\n            addresses[i] = topAddressesOf[dayz][i].owner;\n            totals[i] = dayAchievementOf[addresses[i]][dayz];\n        }\n    }\n\n    function _updateTops(address owner, uint value) internal {\n\n        /* _tryDistributeTopAwards(); */\n\n        if ( owner == address(0) || owner == address(0xdead) ) {\n            return ;\n        }\n\n        uint dayz = timestempZero();\n\n        dayAchievementOf[owner][dayz] += value;\n\n        uint a = dayAchievementOf[owner][dayz];\n\n        AchievementHistory[10] storage tops = topAddressesOf[dayz];\n        bool exist = false;\n\n        if ( tops[tops.length - 1].total > a ) {\n            return ;\n        }\n\n        for ( uint i = 0; i < tops.length; i++ ) {\n            if ( tops[i].owner == address(0) ) {\n                break;\n            } else if ( tops[i].owner == owner ) {\n                tops[i].total = a;\n                exist = true;\n                break;\n            }\n        }\n\n        if ( !exist ) {\n            tops[tops.length - 1].total = a;\n            tops[tops.length - 1].owner = owner;\n        }\n\n        for ( uint i = 0; i < tops.length - 1; i++) {\n            uint max = i;\n            for ( uint j = i + 1; j < tops.length; j++) {\n                if ( tops[j].total > tops[max].total ) {\n                    max = j;\n                }\n            }\n\n            (tops[i].total, tops[max].total) = (tops[max].total, tops[i].total);\n            (tops[i].owner, tops[max].owner) = (tops[max].owner, tops[i].owner);\n        }\n\n    }\n\n}\n\n\npragma solidity >=0.5.1 <0.6.0;\n\n\ncontract ICAToken_Internal_Core is ICAToken_Internal_Top {\n\n    function _send(\n        address _from,\n        address _to,\n        uint _amount,\n        bytes memory _userData,\n        address _operator,\n        bytes memory _operatorData\n    ) internal {\n\n        if ( whiteListModeEnable ) {\n            require( _whiteListMapping[_from] && _whiteListMapping[_to], "NotInWhiteList" );\n        }\n\n        if ( _to == address(0) ) {\n            emit Burned(_operator, _from, _amount, _userData, _operatorData);\n        } else {\n            emit Sent(_operator, _from, _to, _amount, _userData, _operatorData);\n        }\n        emit Transfer(_from, _to, _amount);\n\n        if ( _from == swapPairAddress ) {\n            _updateTops(_to, _amount);\n            _tradingVolumeMapping[timestempZero()] += _amount;\n        }\n\n\n        _balances[_from] = _balances[_from].sub(_amount);\n\n        _balances[_to] = _balances[_to].add( _amount.mul(0.9e12).div(1e12) );\n\n        _balances[BurnedAddress] = _balances[BurnedAddress].add( _amount.mul(0.04e12).div(1e12) );\n\n        uint t = _amount.mul(0.007e12).div(1e12);\n        _balances[BonusAddress_L1]  = _balances[BonusAddress_L1].add(t);\n        _balances[BonusAddress_L2]  = _balances[BonusAddress_L2].add(t);\n        _balances[BonusAddress_L3]  = _balances[BonusAddress_L3].add(t);\n        _balances[BonusAddress_L4]  = _balances[BonusAddress_L4].add(t);\n        _balances[BonusAddress_L5]  = _balances[BonusAddress_L5].add(t);\n\n        _balances[GenesisesAddress]  = _balances[GenesisesAddress].add( _amount.mul(0.01e12).div(1e12) );\n\n        _balances[TopRewardAddress]  = _balances[TopRewardAddress].add( _amount.mul(0.005e12).div(1e12) );\n\n        address parent = iRelations.getIntroducer(_to);\n        _balances[parent] = _balances[parent].add( _amount.mul(0.01e12).div(1e12) );\n\n        uint originBalance = _balances[_from] + _amount + holderInfoOf[_from].total;\n        uint currentBalance = _balances[_from] + holderInfoOf[_from].total;\n        parent = iRelations.getIntroducer(_from);\n\n        if (\n            originBalance >= 10000e6 &&\n            currentBalance < 10000e6 &&\n            holderInfoOf[parent].vaildAddressCount > 0)\n        {\n            holderInfoOf[parent].vaildAddressCount -= 1;\n        }\n\n        if (\n            originBalance < 10000e6 &&\n            currentBalance >= 10000e6\n        ) {\n            holderInfoOf[parent].vaildAddressCount += 1;\n        }\n\n        parent = iRelations.getIntroducer(_to);\n        originBalance = _balances[_to] - (_amount.mul(0.9e12).div(1e12)) + holderInfoOf[_to].total;\n        currentBalance = _balances[_to] + holderInfoOf[_to].total;\n        if (\n            originBalance >= 10000e6 &&\n            currentBalance < 10000e6 &&\n            holderInfoOf[parent].vaildAddressCount > 0\n        ) {\n            holderInfoOf[parent].vaildAddressCount -= 1;\n        }\n        else if (\n            originBalance < 10000e6 &&\n            currentBalance >= 10000e6\n        ) {\n            holderInfoOf[parent].vaildAddressCount += 1;\n        }\n    }\n}\n\n\npragma solidity >=0.5.1 <0.6.0;\n\n\ncontract ICAToken_Internal is ICAToken_Internal_Core {\n\n    function setSwapPairAddress(address pair) external KOwnerOnly {\n        swapPairAddress = pair;\n    }\n}\n\n\npragma solidity >=0.5.1 <0.6.0;\n\n\ncontract ICAToken_Holder is ICAToken_Internal {\n\n    function upgradeLevel() external returns (uint origin, uint current, uint totalAward) {\n\n        HolderInfo storage info = holderInfoOf[msg.sender];\n        origin = info.level;\n        current = origin;\n        address[] memory children = iRelations.recommendList(msg.sender);\n\n        uint vaildAddressCount = 0;\n\n        if (origin == 5) {\n            return (origin, current, totalAward);\n        }\n\n        uint[] memory distribution = new uint[](1 + 5);\n        for ( uint i = 0; i < children.length; i++ ) {\n            distribution[holderInfoOf[children[i]].level] ++;\n            if ( holderInfoOf[children[i]].total + _balances[children[i]] >= 10000e6 ) {\n                ++vaildAddressCount;\n            }\n        }\n        info.vaildAddressCount = vaildAddressCount;\n\n        if ( current == 0 && info.total >= 100000e6 ) {\n            current = 1;\n        }\n\n        if ( current == 1 && info.total >= 100000e6 && info.vaildAddressCount >= 2 ) {\n            current = 2;\n        }\n\n        if ( current == 2 && info.total >= 100000e6 && info.vaildAddressCount >= 4 ) {\n            uint effCount = 0;\n            for (uint i = current; i < distribution.length; i++ ) {\n                effCount += distribution[i];\n            }\n            if ( effCount >= 2 ) {\n                current = 3;\n            }\n        }\n\n        if ( current == 3 && info.total >= 100000e6 && info.vaildAddressCount >= 6 ) {\n            uint effCount = 0;\n            for (uint i = current; i < distribution.length; i++ ) {\n                effCount += distribution[i];\n            }\n            if ( effCount >= 2 ) {\n                current = 4;\n            }\n        }\n\n        if ( current == 4 && info.total >= 100000e6 && info.vaildAddressCount >= 8 ) {\n            uint effCount = 0;\n            for (uint i = current; i < distribution.length; i++ ) {\n                effCount += distribution[i];\n            }\n            if ( effCount >= 2 ) {\n                current = 5;\n            }\n        }\n\n        if ( current > origin ) {\n\n            /* if ( _balances[UpgradeLevelAddress] > 0 ) {\n                uint40[6] memory upgradeAwards = [\n                ];\n\n                for ( uint i = origin; i <= current && i < upgradeAwards.length; i++ ) {\n                    if ( _balances[UpgradeLevelAddress] >= upgradeAwards[i] ) {\n                        totalAward += upgradeAwards[i];\n                        emit Transfer(UpgradeLevelAddress, msg.sender, upgradeAwards[i]);\n                        _balances[UpgradeLevelAddress] = _balances[UpgradeLevelAddress].sub(upgradeAwards[i]);\n                        _balances[msg.sender] = _balances[msg.sender].add(upgradeAwards[i]);\n                    } else {\n                        totalAward += _balances[UpgradeLevelAddress];\n                        emit Transfer(UpgradeLevelAddress, msg.sender, _balances[UpgradeLevelAddress]);\n                        _balances[UpgradeLevelAddress] = 0;\n                        _balances[msg.sender] = _balances[msg.sender].add(_balances[UpgradeLevelAddress]);\n\n                    }\n                }\n            } */\n\n            for (uint i = origin + 1; i <= current; i++) {\n                _levelListMapping[i].push(msg.sender);\n            }\n            info.level = current;\n        }\n\n        return (origin, current, totalAward);\n    }\n\n    function increaseHold(uint amount) external {\n\n        require(_balances[msg.sender] >= amount, "EnsureEnoughFunds");\n\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\n        _balances[HolderAddress] = _balances[HolderAddress].add(amount);\n\n        holderInfoOf[msg.sender].total = holderInfoOf[msg.sender].total.add(amount);\n        holderInfoOf[msg.sender].unlockTime = timestemp() + 1 days;\n\n        emit Log_TransferHold(msg.sender, timestemp(), int(amount), holderInfoOf[msg.sender].total);\n    }\n\n    function decreaseHold(uint amount) external {\n\n        HolderInfo storage info = holderInfoOf[msg.sender];\n\n        require( info.total >= amount && timestemp() >= info.unlockTime, "EnsureEnoughFunds");\n\n        info.total = info.total.sub(amount);\n\n        _balances[HolderAddress] = _balances[HolderAddress].sub(amount);\n        _balances[msg.sender] = _balances[msg.sender].add(amount);\n\n        emit Log_TransferHold(msg.sender, timestemp(), -int(amount), holderInfoOf[msg.sender].total);\n    }\n\n    function distributeHolderAward(uint proportion, uint lv, uint maxLimit) external KOwnerOnly returns (uint totalMembersCount, uint award) {\n\n        require( proportion > 0 && proportion <= 1e12, "InvalidProportion" );\n        require( lv >= 1 && lv <= 5, "InvalidLevelParmas" );\n\n        latestDistributeTime[lv] = timestemp();\n\n        uint8[6] memory effVaildAddressCount = [0, 0, 2, 4, 6, 8];\n\n        uint40[6] memory maxAwardsLimit = [\n            0,\n            80000e6,\n            100000e6,\n            140000e6,\n            160000e6,\n            200000e6\n        ];\n\n        address[] storage lvMembers = _levelListMapping[lv];\n\n        award = _balances[address(lv)].div(lvMembers.length) * proportion / 1e12;\n        if ( award > maxAwardsLimit[lv] ) {\n            award = maxAwardsLimit[lv];\n        }\n\n        for ( uint i = 0; i < lvMembers.length && i < maxLimit; i++ ) {\n\n            if ( holderInfoOf[lvMembers[i]].vaildAddressCount >= effVaildAddressCount[lv] ) {\n\n                _balances[address(lv)] = _balances[address(lv)].sub(award);\n                _balances[lvMembers[i]] = _balances[lvMembers[i]].add(award);\n\n                emit Transfer(address(lv), lvMembers[i], award);\n                emit Log_HoldAwardDistribute(lvMembers[i], lv, timestempZero(), award);\n\n            }\n        }\n\n        return (lvMembers.length, award);\n    }\n\n}\n\n\npragma solidity >=0.5.1 <0.6.0;\n\n\ncontract ICAToken_WhiteList is ICAToken_Internal {\n\n    function pushAddressGroupToWhiteList(address[] calldata whiteAddresses) external KOwnerOnly {\n        for ( uint i = 0; i < whiteAddresses.length; i++ ) {\n            _whiteListMapping[whiteAddresses[i]] = true;\n        }\n    }\n\n    function enableWhiteListMode() external KOwnerOnly {\n        whiteListModeEnable = true;\n    }\n\n    function disableWhiteListMode() external KOwnerOnly {\n        whiteListModeEnable = false;\n    }\n\n}\n\n\npragma solidity >=0.5.1 <0.6.0;\n\n\n\n\ncontract ICAToken is ICATokenStorage("", "", 0, 0, Relations(0) ), ICAToken_Internal, ICAToken_Holder, ICAToken_WhiteList {\n\n    function burnDistribute() external view returns (uint[] memory) {\n\n        uint[] memory distributes = new uint[](6);\n\n        distributes[0] = _balances[BurnedAddress];\n\n        distributes[1] = _balances[BonusAddress_L1] +\n                         _balances[BonusAddress_L2] +\n                         _balances[BonusAddress_L3] +\n                         _balances[BonusAddress_L4] +\n                         _balances[BonusAddress_L5];\n\n        distributes[2] = _balances[TopRewardAddress];\n\n        distributes[3] = _balances[GenesisesAddress];\n\n        distributes[4] = _balances[HolderAddress];\n\n        distributes[5] = _balances[UpgradeLevelAddress];\n\n        return distributes;\n    }\n\n    function tradingDistribute() external view returns (uint[7] memory treadings) {\n        for (\n            (uint i, uint j) = (timestempZero() - (7 + 1), 0);\n            i <= timestempZero() && j < 7;\n            (i += 1 days, j++) )\n        {\n                treadings[j] = _tradingVolumeMapping[i];\n        }\n    }\n\n    function toperDistribute(uint time) external view returns (address[10] memory addresses, uint[10] memory traded, uint[10] memory awards) {\n\n        AchievementHistory[10] memory history = topAddressesOf[time * 1 days / 1 days];\n\n        for (uint i = 0; i < history.length; i++) {\n            addresses[i] = history[i].owner;\n            traded[i] = history[i].total;\n            awards[i] = history[i].actualSent;\n        }\n    }\n\n    function levelDistribute() external view returns (uint[6] memory memberCount, uint[6] memory preAwards) {\n        for ( uint i = 1; i <= 5; i++ ) {\n\n            memberCount[i] = _levelListMapping[i].length;\n\n            if ( memberCount[i] == 0 ) {\n\n                preAwards[i] = _balances[address(i)];\n\n            } else {\n                /* preAwards[i] = preAwards[i - 1] + _balances[address(i)] / memberCount[i]; */\n                preAwards[i] = _balances[address(i)] / memberCount[i];\n            }\n\n            preAwards[i] /= 3;\n        }\n    }\n\n    function childrenHoldDistribute(address parent) external view returns (address[] memory children, uint[] memory holds, uint[] memory balances) {\n        children = iRelations.recommendList(parent);\n        holds = new uint[](children.length);\n        balances = new uint[](children.length);\n\n        for ( uint i = 0; i < children.length; i++ ) {\n            holds[i] = holderInfoOf[children[i]].total;\n            balances[i] = _balances[children[i]] + holds[i];\n        }\n    }\n}\n')])])])}]},1171:function(n,e,r){"use strict";r.r(e);var t,a=r("52c0"),s=r.n(a);for(t in a)["default"].indexOf(t)<0&&function(n){r.d(e,n,function(){return a[n]})}(t);e.default=s.a},"2e63":function(n,e,r){"use strict";r("2ea8")},"2ea8":function(n,e,r){},"4dd9":function(n,e,r){"use strict";r.r(e);var t,a=r("0b7e"),s=r("1171");for(t in s)["default"].indexOf(t)<0&&function(n){r.d(e,n,function(){return s[n]})}(t);r("2e63");var o=r("2877"),a=Object(o.a)(s.default,a.a,a.b,!1,null,"167d91f6",null);e.default=a.exports},"52c0":function(n,e){},"5fb6":function(n,e){n.exports="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACQAAAAkCAYAAADhAJiYAAADoElEQVRYR+2XQYhVdRTGf5/IVCIVEipTSERGaIWoiGi0CJEICZWEiBCJiIgIV+JSWoiICxEREQkJkRAXowhBiIsYMnKwQYZoERFiISEVIiIyzJFvOP/hdnvv3as8ni78b4Z5795zf/ec73znPJEnIp4BNgHPls8G8He/pH+rz5H/iYjHgU+BJwcAUX1EV6CVwAbgJnAZuDMgsB8k3e6UoY3AMuCUpIkBwXR8TCnZVuAF4Jik3x8GoG3A84MEioghYDmwAPgDGJc0WTI0UKCImAN8CLizy7kCfPWggIpm/wQM8gowFzg/cKCImAXsBG4AhyRNRcQ84DPg7wcB9DSwHRiVdK5izB8Dw62A8q1WAYvTqy5Kuno/3Zgm7AxZxCMVIEMOtQV6N+tc7p8CTkj69T6hnI352dVXI2INsB6YaASKiJeA911f4HvA9V6dmbL1G+6eTkS43d/Jm+zUHl2eDkfbAHmkeLRYgH/l7HMwB/1Skruk9YkId5Mz5LlZYK4BZy2DNkD2qIWS9lTq7THj1h2RNN6WJmEcz/4zJuls/d42QMUz9kny8PV2sA54HTjeVkfpzB+ldn7Oufm/crcBeg3YDFjA3wBu2y1Z9zHgW0k9t4OE+QBYBHSF8cv2BMp2fw+wsOtnEpgN/AOcrg7liHjMiTRoxjCMh7f15qx2fYECZKE5+E0PuIpW3gTeAH4DLGiDWYjuNgvR5Xwur7eWRoG3gBcBl+Mn4AlgSS+YiHjZOp32pm6CjIhSKrf7kfoilVryGLAFGNwv1O1cz4681emCiCg6PdYRKCKGAXeDj2EcsOvJfdzm6bf8BTiTbe1yW3MzltEKKO18babfpVia07e1G0eEhe+szuzJEeFx8zZwUpLF3PH8J0MJ43as7ia+8byk7+7BY8rW+UVx74rL9/SrOpBniGeJhWthWmAW4SVJTn2rExEWs/X0tSSXzX5VXL7nalwH+txTNlM9mW36iTVQdecmqtSdR4Jb2t32FLAiZ+DBXjOvDrTLpifpeKXdy6yaSX8TUGakZLtcbjj7Ts95VwfaAbgdp7e3DOwOG5a0uw1I9ZrUjcvumC67baPnqQOV7vgRuAC8mr4yIelUU7B+fF8H8n5jzVhH5diND9d/d/fj4W19yIbm+nv4ud7eTRpT3S/ARqfu14PaxnkE1JSpiJj+CQQc6DZcyzrQFKsf3xvEa80tSXu7AZV1oB8PbBvjnKTRhwHIbu5V2EBTdwGegerCOgq+nwAAAABJRU5ErkJggg=="}}]);